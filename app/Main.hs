{-# LANGUAGE LambdaCase #-}
module Main where

import System.IO
import Control.Monad
import Data.Maybe
import Data.List (intercalate)
import qualified Data.Map as M
import Debug.Trace
import System.Directory
import System.Environment
import qualified Data.Text as T
import CodeBodies
import RawBodies
import Declarations
import Convert
import Headers
import Manifest
import Type
import Encode

writeModule :: p
            -> String
            -> String
            -> ( Maybe String
               , p -> String -> Maybe String -> String
               , String
               )
            -> IO ()
writeModule backend directory moduleName (subModuleName, headerF, body)
    = writeFile fn string
    where fn = directory ++ "/" ++ moduleName
            ++ (case subModuleName of Just n -> "/" ++ n; Nothing -> "") ++ ".hs"
          string = headerF backend moduleName subModuleName ++ body

showUsage :: IO ()
showUsage =
    putStrLn $ unlines [ "Usage: futhask futhark_json haskell_src_dir module_name [OPTIONS]"
                       , "    futhark_json - the json manifest file generated by the futhark compiler."
                       , "    haskell_src_dir - path to the directory where futhask should output generated code. (Often \"src\") "
                       , "    module_name - name of the module branch for generated code. "
                       , "    --lineartypes - optional create linear type signature for entry functions."
                       , "    --debug - create a stack trace to catch runtime errors."
                       , ""
                       , "    Example: futhask fut/entries.json src Futhark"
                       , "     will given a project with a fut directory and a haskell src directory produce a directory /src/Futhark "
                       , "     and build modules with names such as Futhark.TypeClasses."
                       ]

main :: IO ()
main = do
    putStrLn "Starting futhask version 0.2.4:"
    args <- getArgs
    ([jsonName, srcDir, moduleName],xs) <- getArgs >>= \case
         a:b:c:xs -> return ([a,b,c], xs)
         _            -> do showUsage; error ""
    let useLinear = "--lineartypes" `elem` xs
    let debugMode = "--debug" `elem` xs
    when useLinear $ putStrLn "Using linear types."
    when debugMode $ putStrLn "Using debug mode."
    createDirectoryIfMissing False (srcDir ++ "/" ++ moduleName)
    manifest <- readManifest jsonName
    let backend = manifestBackend manifest
        typeMap = buildFutharkTypes manifest
        types   = M.elems typeMap
        entries = M.elems $ buildEntries typeMap manifest
    dataWrappers   <- foreignDataWrappers         types
    typeOps        <- foreignTypeOpDeclarations   types
    instances      <- haskellInstanceDeclarations types
    foreignEntries <- foreignEntryDeclarations    entries
    haskellTypes   <- haskellDataWrappers         types
    haskellEntries <- haskellEntryDeclarations useLinear False debugMode entries
    mapM_ (writeModule backend srcDir moduleName)
        [ (Just "Raw"        , rawHeader                    debugMode ,    commonRawBody
                                                                       ++ rawBody backend
                                                                       ++ dataWrappers
                                                                       ++ foreignEntries
                                                                       ++ typeOps               )
        , (Just "Entries"    , entriesHeader                debugMode, haskellEntries           )
        , (Just "Types"      , typesHeader                  debugMode, haskellTypes ++ instances)
        , (Just "TypeClasses", typeClassesHeader useLinear  debugMode, typeClassesBody          )
        , (Just "Context"    , contextHeader                debugMode, contextBody              )
        , (Just "Config"     , configHeader                 debugMode, configBody backend       )
        , (Just "Fut"        , futHeader         useLinear  debugMode, futBody useLinear        )
        , (Just "Wrap"       , wrapHeader                   debugMode, wrapBody                 )
        , (Just "Utils"      , utilsHeader                  debugMode, utilsBody                )
        , (Nothing, exportsHeader debugMode, "") ]
    putStrLn "Futhask wrapper generation complete."
